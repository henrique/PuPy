'''
Created on Apr 29, 2014

@author: "Nico Schmidt"
'''
import numpy as np
from scipy.signal import convolve


def gauss_kern(size, sizey=None):
    """ Returns a normalized 2D gauss kernel array for convolutions
    borrowed from http://wiki.scipy.org/Cookbook/SignalSmooth
    """
    size = int(size)
    if not sizey:
        sizey = size
    else:
        sizey = int(sizey)
    x, y = np.mgrid[-size:size+1, -sizey:sizey+1]
    g = np.exp(-(x**2/float(size)+y**2/float(sizey)))
    return g / g.sum()


def no_kern(): return np.array([])


def generate_surface(size=(10,10), std=1, kernel=None, height=None):
    """Returns flat array with surface heights to be used with Webots elevation grid. 
    """
    def make_edges(a):
        for x in range(size[0]):
            a[x,0] = 0.0
            a[x,-1] = 0.0
        for z in range(1,size[1]-1):
            a[0,z] = 0.0
            a[-1,z] = 0.0
        return a        
    a = np.random.normal(scale=std, size=size)
    a = make_edges(a)
    if kernel is not None:
        a = convolve(a, kernel[0](*kernel[1]), 'same')
    if height is not None:
        a /= a.max() - a.min()
        a *= height
    a = make_edges(a)
    return a.flatten(order='F')


def get_world_string():
    """Get the default world file content as two strings. 
    Contact properties should be inserted between the two and surfaces and additional objects after the second string.
    """
    s1 = '#VRML_SIM V6.0 utf8\n' + \
         'WorldInfo {\n' + \
         '  info [\n' + \
         '    "Author: auto-generated by a script from Nico Schmidt using a template by Matej Hoffmann"\n' + \
         '    "AI lab Zurich"\n' + \
         '    "Date: Dec 2011"\n' + \
         '    "This model was created from the MiniDog model for ShanghAI (without STL eye candy) and scaled up to match Puppy\'s dimensions."\n' + \
         '  ]\n' + \
         '  title "Puppy"\n' + \
         '  CFM 0.0001\n' + \
         '  ERP 0.6\n' + \
         '  basicTimeStep 2\n' + \
         '  runRealTime TRUE\n' + \
         '  defaultDamping Damping {\n' + \
         '  }\n' + \
         '  contactProperties [\n'
    s2 = '  ]\n' + \
         '}\n' + \
         'Viewpoint {\n' + \
         '  fieldOfView 0.795398\n' + \
         '  orientation -0.08 0.98 0.14 2.1\n' + \
         '  position 2 0.7 -1\n' + \
         '  follow "puppy"\n' + \
         '}\n' + \
         'Background {\n' + \
         '  skyColor [\n' + \
         '    0.4 0.7 1\n' + \
         '  ]\n' + \
         '}\n' + \
         'DirectionalLight {\n' + \
         '  direction 0.05 -0.12 -0.06\n' + \
         '}\n' + \
         'DirectionalLight {\n' + \
         '  direction -0.07 -0.05 -0.06\n' + \
         '}\n' + \
         'MetricFloor {\n' + \
         '  translation 0 -0.5 0\n' + \
         '  color 0.521569 0.462745 0.462745\n' + \
         '}\n'
    return s1, s2


def get_materials_string(terrain_list):
    """Return the Material definition for the Webots world file.
    """
    material_string = ''
    for name, _, contact_properties, _ in terrain_list:
        contact_properties.setdefault('coulombFriction', 1)
        contact_properties.setdefault('bounce', 0.5)
        contact_properties.setdefault('bounceVelocity', 0.01)
        contact_properties.setdefault('forceDependentSlip', 0)
        material_string += '    ContactProperties {\n' + \
                           '      material1 "%s_MATERIAL"\n' % name.upper() + \
                           ''.join(['      '+k+' '+str(v)+'\n' for k,v in contact_properties.items()]) + \
                           '    }\n'
    return material_string


def get_terrain_protos_string(terrain_list, patch_size=(1,1)):
    """Create a string that can be used as Webots prototype.
    Depending on the terrain type, a Box or an ElevationGrid is created.
    The terrain_list is a list of terrain types as specified in generate_terrain().
    The patch_size is in Webots coordinates (x,y).
    """
    terrain_proto_strings = []
    for name, surface_vector, _, texture in terrain_list:
        
        if surface_vector is None:
            geometry = '      geometry Box {\n' + \
                       '        size %f 0.01 %f\n' % patch_size + \
                       '      }\n'
        else:
            x = np.sqrt(len(surface_vector))
            assert x%1 == 0.0 # grid must be square shape
            geometry = '      geometry ElevationGrid {\n' + \
                       '        color Color {' + \
                       '        }\n' + \
                       '        height [\n' + ', '.join(map(str, surface_vector)) + '\n' + \
                       '        ]\n' + \
                       '        colorPerVertex FALSE\n' + \
                       '        xDimension %d\n' % int(x) + \
                       '        xSpacing %f\n' % (float(patch_size[0]) / (x-1)) + \
                       '        zDimension %d\n' % int(x) + \
                       '        zSpacing %f\n' % (float(patch_size[1]) / (x-1)) + \
                       '      }'
        if texture is None:
            texture = name
        s = 'PROTO %s [\n' % (name[0].upper()+name[1:]) + \
            '  field SFVec3f translation 0 0 0\n' + \
            '] {\n' + \
            '  Solid {\n' + \
            '    translation IS translation\n' + \
            '    children [\n' + \
            '      DEF %s_SHAPE Shape {\n' % name.upper() + \
            '        appearance Appearance {\n' + \
            '          material DEF %s_MATERIAL Material {\n' % name.upper() + \
            '          }\n' + \
            '          texture ImageTexture {\n' + \
            '            url [\n' + \
            '              "textures/%s.jpg"\n' % texture + \
            '            ]\n' + \
            '          }\n' + \
            '          textureTransform TextureTransform {\n' + \
            '            scale %d %d\n' % patch_size + \
            '          }\n' + \
            '        }\n' + geometry + \
            '      }\n' + \
            '    ]\n' + \
            '    contactMaterial "%s_MATERIAL"\n' % name.upper() + \
            '    boundingObject USE %s_SHAPE\n' % name.upper() + \
            '    locked TRUE\n' + \
            '  }\n' + \
            '}\n'
        terrain_proto_strings.append(s)
    return terrain_proto_strings


def get_terrain_string(name='bluefoil', pos=(0,0)):
    """Return the string specifying a terrain patch for a Webots world file.
    pos is a (x,z) coordinate.
    """
    terrain_string = '%s {\n' % (name[0].upper()+name[1:]) + \
                     '  translation %f 0 %f\n' % pos + \
                     '}\n'
    return terrain_string


def get_terrain_index_string(terrain_idx, size, patch_size, as_comment=False):
    """Return the terrain index map as a string that can be included into the webots file.
    """
    if as_comment:
        idx_string = '# Arena of size (%f,%f) with patches of size (%f,%f) of %d different terrain types:\n' % \
                     (size+patch_size+(len(np.unique(terrain_idx)),))
    else:
        idx_string = '%f %f\n%f %f\n%d\n' % (size+patch_size+(len(np.unique(terrain_idx)),))
    for h in range(terrain_idx.shape[0]):
        if as_comment:
            idx_string += '# ' + ' '.join(map(str,terrain_idx[h,:])) + '\n'
        else:
            idx_string += ' '.join(map(str,terrain_idx[h,:])) + '\n'
    return idx_string
def read_terrain_index(filename):
    """Read the terrain index that was stored in get_terrain_index_string() from disk.
    """
    with open(filename, 'r') as f:
        s = f.readlines()
    size = map(float, s[0][:-1].split(' '))
    patch_size = map(float, s[1][:-1].split(' '))
    N = int(s[2][:-1])
    X = int(size[0]/patch_size[0])
    Z = int(size[1]/patch_size[1])
    terrain_idx = np.empty([Z,X], dtype=int)
    for z in range(Z):
        terrain_idx[z,:] = map(int, s[z+3][:-1].split(' '))
    return terrain_idx, size, patch_size, N


def get_terrain_index_from_position(pos, terrain_idx, size, patch_size):
    """Extract the terrain index from the robots position.
    """
    x = (pos[0]+size[0]/2.0) / patch_size[0]
    z = (pos[1]+size[1]/2.0) / patch_size[1]
    if 0<=z and z<terrain_idx.shape[0] and 0<=x and x<terrain_idx.shape[1]:
        return terrain_idx[int(z),int(x)]
    else:
        return -1


def generate_terrain(terrains, size, patch_size):
    """Function to generate a world with random placement of patches from the terrains list.
    size and patch_size are in world coordinates (x,z).
    The terrain list contains one or more lists of length 4:
        [name_string, surface_array, material_dict, texture_string]
        
    Returns a 3-tuple containing
        (a) a list of terrain patches as prototype strings,
        (b) the world file as a string and
        (c) the terrain index as a 2D array. In the array, row-indices are x-positions, column-indices are z positions.
    """
    size = (size[0]-size[0]%patch_size[0], size[1]-size[1]%patch_size[1]) # size is resized if does not match patch_size
    X = int(size[0]/patch_size[0])
    Z = int(size[1]/patch_size[1])
    
    world_string, world_string2 = get_world_string()
    material_string = get_materials_string(terrains)
    terrain_protos = get_terrain_protos_string(terrains, patch_size)
    terrain_string = ''
    terrain_idx = np.empty((Z,X), dtype=int) # note that in the matrix rows are x, cols are z 
    for zi in range(Z):
        for xi in range(X):
            terrain_idx[zi,xi] = np.random.choice(len(terrains))
            name, surface, _, _ = terrains[terrain_idx[zi,xi]]
            x = xi*patch_size[0]-size[0]/2.0
            z = zi*patch_size[1]-size[1]/2.0
            if surface is None:
                x += patch_size[0]/2.0
                z += patch_size[1]/2.0
            #print (zi,xi), (x, z)
            terrain_string += get_terrain_string(name, (x,z))
    return terrain_protos, world_string + material_string + world_string2 + terrain_string, terrain_idx


def save_string(filename, string):
    with open(filename, 'w') as f:
        f.write(string)


default_terrains = [['bluefoil', None, {'coulombFriction':2}, 'bluefoil'],
                    ['cardboard', None, {'coulombFriction':11}, 'cardboard'],
                    ['styrofoam', None, {'coulombFriction':9}, 'styrofoam'],
                    ['rubber', None, {'coulombFriction':20}, 'rubber']]

new_terrains = [['groundIce', None, {'coulombFriction':0.1, 'bounce':0.0}, 'bluefoil'],
                ['groundRubber', None, {'coulombFriction':2.5, 'bounce':0.6}, 'rubber'],
                ['groundStyrofoam', None, {'coulombFriction':1, 'bounce':0.3}, 'styrofoam'],
                ['groundRough', generate_surface((20,20), 0.005, None, None), {'coulombFriction':1, 'bounce':0.5}, 'cardboard'],
                ['groundWaves', generate_surface((20,20), 1.0, [gauss_kern, (5,)], 0.06), {'coulombFriction':1, 'bounce':0.05}, 'bluefoil']]

if __name__ == '__main__':
    import os, PuPy
    path = os.path.split(PuPy.__file__)[0]
    filename = 'test_terrain'
    
    # create terrain:
    size = (5,7.5)
    patch_size = (1.25,2.5)
    protos, world, terrain_idx = generate_terrain(new_terrains, size, patch_size)
    
    for p in protos: print p
    print world
    print terrain_idx
    
    save_string(path+'/../starter/data/terrain/'+filename, world)
    save_string('/tmp/terrain_idx', get_terrain_index_string(terrain_idx, size, patch_size))
    for s,name in zip(protos,new_terrains):
        save_string(path+'/../starter/data/supplementary/protos/'+name[0][0].upper()+name[0][1:]+'.proto', s)
    
    cmd = path+'/../starter/world_builder.sh '+ \
               '-t ' + filename + ' ' + \
               '-c webotsRobotController.py '+ \
               '-s webotsSupervisorController.py '+ \
               '-m run '+ \
               'out'
    print cmd
    os.system(cmd)

